// ----------------------------------------------------------------------------
// Bearded2.cpp
// ----------------------------------------------------------------------------
// BasiCKMR: single-sex boring-adulthood known-age POP-only (MDP) CKMR
// assumes long-term exponential growth/decline in Number-of-adults

#include "Bearded2.hpp"
#include <R.h>


// ----------------------------------------------------------------------------


// CONSTRUCTOR: you may not need to change this, if your data all comes from...
// R in one single hit
Bearded2::Bearded2(
#include "Bd_constructor_args.hpp"
)
 : AdtArrays()
{

  // include-files below are auto-generated by ADT based on the dot-hpp
  // Next line may bomb if no constructor-locals (used to; maybe fixed now)
  #include "Bd_constructor_locals.hpp"

  // Always need these two
  #include "Bd_constructor_scalars_phase_1.hpp"
  #include "Bd_constructor_arrays_phase_1.hpp"

  // Now you can do some calculations to work out further array dims...
  // that depend on stuff just passed in. Then:
  // eg  #include "Bd_constructor_arrays_phase_2.hpp"
  // etc. Might as well pass in all scalars during PHASE 1 though
  // NB PHASES are defined in the dot-hpp

  // Could do data-summary calcs here
  // but NB *no* bounds-checks inside the constructor (for good reason)
  // so I've put them into a separate function
  // Hmmm, should check: ?arrays that need to be precalced...
  // before array_plans_init

  // make_data_summaries(); Has to be called OUTSIDE the constructor at present... ADT / ViStu thing

  #include "Bd_array_plans_init.hpp"
}; // constructor


void Bearded2::calc_n_comps(const ARRAY_3D mm_tas/* first_y:last_y, 1:n_ages, 0:1 */)
{
	int i_t, i_t2, i_age, i_age2,i_by1, i_by2, i_sex, i_samp, j_samp, this_by, this_oby, this_capt, this_pby, this_maty, this_sex, i_POP, i_HS, min_y, max_age1, max_age2;



	// Number of comparisons. Here we are treating PO as DIRECTIONAL, ie
	// 1st animal in the pair must be the Parent, and 2nd animal the Offspring
	// Look at calc_probs code first to understand why these variables are use

	//  comparisons by parent birth year [y], parent death year [t], offspring birth year [b], 
	//  sex [s] (0 = female), and whether there is a match or not [m]
	zero(n_comps_ytbs);
	zero(n_hs_comps_bbs);

	for (i_sex = 0; i_sex <= 1; i_sex++) {  //parent sex
		for (i_t = first_y_sample; i_t <= last_y; i_t++) { //parent death
			for (i_age = amat; i_age <= n_ages; i_age++) {  //parent age at death
				this_maty = i_t - i_age + amat;
				min_y = max(this_maty, first_y_sample);
				for (i_t2 = min_y; i_t2 <= last_y; i_t2++) { //offspring death
					for (i_age2 = 1; i_age2 < n_ages;i_age2++) { //offspring age
						this_oby = i_t2 - i_age2 + 1;
						this_pby = i_t - i_age + 1;
						if ((this_oby >= this_maty) && (this_maty <= last_y) && (this_oby < i_t) && (this_oby != i_t) && (this_pby > 0)) {
							n_comps_ytbs[this_pby][i_t][this_oby][i_sex] = n_comps_ytbs[this_pby][i_t][this_oby][i_sex] + mm_tas[i_t][i_age][i_sex] * (mm_tas[i_t2][i_age2][0] + mm_tas[i_t2][i_age2][1]);
						}
					}
				}
			}
		}
	}
	for (i_t = first_y_sample; i_t <= last_y; i_t++) {
		max_age1 = min(i_t, n_ages);  //prevent birth years < 1
		for (i_age = 1; i_age <= max_age1;i_age++) {
			i_by1 = i_t - i_age + 1;
			for (i_t2 = first_y_sample; i_t2 <= last_y; i_t2++) {
				max_age2 = min(i_t2, n_ages);
				for (i_age2 = 1; i_age2 <= max_age2;i_age2++) {
					i_by2 = i_t2 - i_age2 + 1;
					if (i_by1 < i_by2) {  //prevent double counting
						n_hs_comps_bbs[i_by1][i_by2][0] += (mm_tas[i_t][i_age][0] + mm_tas[i_t][i_age][1]) * (mm_tas[i_t2][i_age2][0] + mm_tas[i_t2][i_age2][1]);
						n_hs_comps_bbs[i_by1][i_by2][1] = n_hs_comps_bbs[i_by1][i_by2][0];
					}
				}
			}
		}
	}
}

void Bearded2::make_data_summaries()
{
  int i_t,i_t2,i_age,i_age2,i_by1,i_by2,i_sex, i_samp, j_samp,this_by, this_oby, this_capt, this_pby,this_maty,this_sex,i_POP,i_HS,min_y,max_age1,max_age2;

  calc_n_comps(m_tas);
  
   // compute birth years for each sampled animal
  for( i_samp = 1; i_samp <= n_samp; i_samp++) {
    this_by = tcap[ i_samp] - a[ i_samp] + 1;
    by[ i_samp] = this_by;

    // For i_samp as possible parent, need year of maturity...
    // or, if that's < first_y, just use first_y...
	ymat_atmost[ i_samp] = max( first_y, this_by + amat -1);  //note: we'll need to avoid doing comparisons where parent and offspring are both "born" in first_y
  }; // i_samp

  // Number of comparisons. Here we are treating PO as DIRECTIONAL, ie
  // 1st animal in the pair must be the Parent, and 2nd animal the Offspring
  // Look at calc_probs code first to understand why these variables are use
  
  //  comparisons by parent birth year [y], parent death year [t], offspring birth year [b], 
  //  sex [s] (0 = female), and whether there is a match or not [m]
  zero(n_match_ytbs);
  zero(n_hs_match_bbs);



  for (i_POP = 1; i_POP <= n_POP; i_POP++) {
	i_samp = isamp_POP[i_POP];
	j_samp = jsamp_POP[i_POP];

	// First case: i is P, j is O
	this_oby = by[j_samp];
	this_pby = by[i_samp];
	this_capt = tcap[i_samp];
	this_maty = ymat_atmost[i_samp];
	this_sex = sex[i_samp];

	// exclude born-in-year-of-cap - this will also remove case where offspring born <= year 1
	if ((this_oby >= this_maty) && (this_maty <= last_y) && (this_oby<this_capt) && (this_oby != this_capt)) {
		n_match_ytbs[this_pby][this_capt][this_oby][this_sex] += 1;
	}

	// Second case: i is O, j is P
	this_oby = by[i_samp];
	this_pby = by[j_samp];
	this_capt = tcap[j_samp];
	this_maty = ymat_atmost[j_samp];
	this_sex = sex[j_samp];

	// exclude born-in-year-of-cap from comparisons
	if ((this_oby >= this_maty) && (this_maty <= last_y) && (this_oby<this_capt)) {
		n_match_ytbs[this_pby][this_capt][this_oby][this_sex] += 1;
	}
  } // i_POP

  for (i_HS = 1; i_HS <= n_HS; i_HS++) {
	  i_samp = isamp_HS[i_HS];
	  j_samp = jsamp_HS[i_HS];

	  if (by[i_samp] != by[j_samp]) {
		  if (by[i_samp] < by[j_samp]) {
			  n_hs_match_bbs[by[i_samp]][by[j_samp]][sex_HS[i_HS]] += 1;
		  }
		  else {
			  n_hs_match_bbs[by[j_samp]][by[i_samp]][sex_HS[i_HS]] += 1;
		  }
	  }
  } // i_HS

  // ... NB I don't mind using if's in the constructor, since it's only run once
  // ... in lglk code, one_if() is faster

}; // make_data_summaries

// ----------------------------------------------------------------------------

// Unpack R parameter-vector into meaningful pop dyn params
void Bearded2::unpack(
  const ARRAY_1D pars/*n_par*/
){
  int i;

  // Surely there is a copy-style function in ADT/C ? No doc of it tho
  // ADT Pascal has one
  for ( i = 1; i <= n_par; i++) {
    temp_pars[ i] = pars[ i];
  }
  nextpari = 1;

  R0 = exp( next_param());
  a_haz = exp(next_param());
  b_haz = exp(next_param()) + 1.0;
  c_haz = exp(next_param());
  //b_mort = exp(next_param());
  //c_mort = exp(next_param());
  //d_mort = exp(next_param());

  // Hide the next bit from  ADT; for one thing, strings aren't understood...
  // but there never any reason to AD this, so don't
  #ifndef AD
  if( nextpari != n_par+1) {
    Rf_error( "Wrong number of params was extracted in unpack...");
    // ... and that's how you signal an error
  };
  #endif
}; // unpack

// Helper for unpack
double Bearded2::next_param() {
  double val;
  ////
  val = temp_pars[ nextpari];
  nextpari += 1;
  return(val);
}; // next_param

// ---------------------------------------------------------------------------

// Fill in pop dyn from parameters. Age-structured version is more interesting
void Bearded2::populate(
  int dummy
){
  int y,isex,i,j,iage;
  double denom;
  
  zero(S_aij);
  // Fill survival array
  for (iage = 1; iage <= n_ages; iage++) {
	  for (i = first_y; i <= last_y; i++) {
		  for (j = i + 1; j <= last_y; j++) {  //implies no matches if half sibs born in same year
			  S_aij[iage][i][j] = exp(haz_mult*(-pow(a_haz*(iage + j - i - 1), b_haz) - pow(a_haz*(iage + j - i - 1), 1.0 / b_haz) - c_haz * (j - i)
				  + pow(a_haz*(iage-1), b_haz) + pow(a_haz*(iage-1), 1.0 / b_haz)));
		  }
	  }
  }

  zero(N_yas);
  zero(N_yas_breed);
  N_yas[first_y][1][0] = R0;
  N_yas[first_y][1][1] = R0;
  for (iage = 2; iage <= n_ages; iage++) {  //fill initial age composition
	  N_yas[first_y][iage][0] = N_yas[first_y][iage - 1][0] * S_aij[iage-1][1][2]; 
	  N_yas[first_y][iage][1] = N_yas[first_y][iage][0]; //survival is constant over sex
  }
  
  for (y = first_y; y < last_y; y++) {  
	  for (iage = 1; iage < n_ages; iage++) {
		  for (isex = 0; isex <= 1; isex++) {
			  N_yas_breed[y][iage][isex] = N_yas[y][iage][isex] * S_aij[iage][1][2];
			  N_yas[y + 1][iage + 1][isex] = N_yas_breed[y][iage][isex];
		  }
		  N_yas[y+1][1][0] += Fec_as[iage][0] * N_yas_breed[y][iage][0];
	  }
	  N_yas_breed[y][n_ages][0] = N_yas[y][n_ages][0] * S_aij[n_ages][1][2];
	  N_yas_breed[y][n_ages][1] = N_yas_breed[y][n_ages][0];
	  N_yas[y + 1][1][0] += Fec_as[n_ages][0] * N_yas_breed[y][n_ages][0];
	  N_yas[y + 1][1][1] = N_yas[y + 1][1][0];
  }
  for (iage = 1; iage <= n_ages; iage++) {
	  for (isex = 0; isex <= 1; isex++) {
		  N_yas_breed[last_y][iage][isex] = N_yas[last_y][iage][isex] * S_aij[iage][1][2];
	  }  
  }

  //relative reproductive output 
  for( y = first_y; y <= last_y; y++){
	  for (isex = 0; isex <= 1; isex++) {
		  denom = 0;
		  for (iage = 1; iage <= n_ages; iage++) {
			  denom += N_yas_breed[y][iage][isex] * Fec_as[iage][isex];
		  }  
		  for (iage = 1; iage <= n_ages; iage++) {
			  rel_repro_yas[y][iage][isex] = Fec_as[iage][isex] / denom;
		  }
	  } //isex
  }  //y






} // populate

// ---------------------------------------------------------------------------

// All CKMR probs
void Bearded2::calc_probs(
  int dummy
){
	int pby, pcapt, isex, oby, oby2,iage;
	double denom1;
	double denom2;
	double small;
	small = 0.00000000001;
  ////

  zero( Pr_PO_ytbs);
  for( pby = first_y+1; pby <= last_y; pby++){
	for (pcapt = first_y_sample; pcapt <= last_y; pcapt++) {
      for( oby = pby+1; oby <= last_y; oby++){
		  iage = oby - pby + 1;
		  if(iage<=n_ages){
			  for (isex = 0; isex <= 1; isex++) {
				  Pr_PO_ytbs[pby][pcapt][oby][isex] = small+
					  one_if(pcapt >= oby) * one_if((pcapt - pby) <= 38)*one_if((pby - oby) <= 38) * rel_repro_yas[oby-1][iage-1][isex];
			  }  //isex
		  } 
      } // oby
    } // pcapt
  } // pmaty

  zero(Pr_HS_bbs);
  for (isex = 0; isex <= 1; isex++) {
	  for (oby = first_y+1; oby <= last_y; oby++) {
		  denom1 = 0.0;
		  for (iage = 2; iage <= (n_ages+1); iage++) {
			  denom1 += Fec_as[iage-1][isex] * N_yas_breed[oby-1][iage-1][isex];
		  }
		  for (oby2 = oby + 1; oby2 <= last_y; oby2++) {
			  denom2 = 0.0;
			  for (iage = 2; iage <= (n_ages+1); iage++) {
				  denom2 += Fec_as[iage-1][isex] * N_yas_breed[oby2-1][iage-1][isex];
			  }
			  for (iage = 2; iage <= (n_ages+1); iage++) {
				  if ((iage + oby2 - oby) <= n_ages) {
					  //Pr_HS_bbs[oby][oby2][isex] += N_yas_breed[oby-1][iage][isex] * S_aij[iage+1][oby][oby2] * rel_repro_yas[oby-1][iage][isex] * rel_repro_yas[oby2-1][iage + oby2 - oby][isex];
					  Pr_HS_bbs[oby][oby2][isex] += N_yas_breed[oby-1][iage-1][isex] * S_aij[iage-1][oby-1][oby2-1] * Fec_as[iage-1][isex]/denom1 * Fec_as[iage+oby2-oby-1][isex]/denom2;
				  }
			  }
		  } //oby2
	  }  //oby
  } //isex
} // calc_probs

// ----------------------------------------------------------------------------

// Log-likelihood
double Bearded2::lglk(
  const ARRAY_1D pars/* n_par */
){
  int pby, pcapt, isex,oby,oby2;
  double tot_lglk;
  ////

  unpack(pars);
  populate(0); // dummy arg
  calc_probs(0);

  tot_lglk = 0;


  //////  PO Pairs  ////// 
  zero(exp_match_ytbs);
  for (isex = 0; isex <= 1; isex++) {
      for (pby = first_y; pby <= last_y; pby++) {
	      for (pcapt = first_y; pcapt <= last_y; pcapt++) {
		      for (oby = first_y; oby <= last_y; oby++) {  
				  if (n_comps_ytbs[pby][pcapt][oby][isex] > 0 && Pr_PO_ytbs[pby][pcapt][oby][isex] == 0.0) {
					  oby2 = 1;
				  }
				  if (n_match_ytbs[pby][pcapt][oby][isex] > 0 && Pr_PO_ytbs[pby][pcapt][oby][isex] == 0.0) {
					  oby2 = 1;
				  }
				  exp_match_ytbs[pby][pcapt][oby][isex] = n_comps_ytbs[pby][pcapt][oby][isex] * Pr_PO_ytbs[pby][pcapt][oby][isex];
				  tot_lglk +=
					  n_log_p(n_match_ytbs[pby][pcapt][oby][isex],exp_match_ytbs[pby][pcapt][oby][isex])-exp_match_ytbs[pby][pcapt][oby][isex];
					  //n_log_p(n_match_ytbs[pby][pcapt][oby][isex], Pr_PO_ytbs[pby][pcapt][oby][isex]) +
					  //n_log_p(n_comps_ytbs[pby][pcapt][oby][isex]- n_match_ytbs[pby][pcapt][oby][isex],1.0 - Pr_PO_ytbs[pby][pcapt][oby][isex]);
			  } //oby
		  } // pcapt
	  } // pmaty
  } // isex


  //////   Half Sibs  //////

  for (isex = 0; isex <= 1; isex++) {
	  //for (pby = first_y; pby <= last_y; pby++) {  //we'll skip parent birth year since we'll be assuming constant survival of matures for now 
		  //pmaty = pby + amat;
		  for (oby = first_y+1 ; oby <= last_y; oby++) {  //we need to give a parents birth year such that they will be mature 
			  for (oby2 = oby + 1; oby2 <= last_y; oby2++) {
				  if (n_hs_match_bbs[oby][oby2][isex] > 0 && Pr_HS_bbs[oby][oby2][isex] == 0.0) {
					  pby = 1;
				  }
				  tot_lglk += n_log_p(n_hs_match_bbs[oby][oby2][isex], Pr_HS_bbs[oby][oby2][isex] *
					  n_hs_comps_bbs[oby][oby2][isex]) -
					  n_hs_comps_bbs[oby][oby2][isex]*Pr_HS_bbs[oby][oby2][isex];
			  }  
		  }
	  //}
  }

  /// priors on survival pars
  tot_lglk -= wt_a*(pow(a_haz-a_mean,2)+ wt_b*pow(b_haz - b_mean,2) + wt_c*pow(c_haz-c_mean,2)); //weight of 50 equiv to SE = 0.1

  // Bin version *without* n_log_p needs if-statements to avoid log(0)
  // and should use log1p( -Pr_PO_ytb[ pmaty][ pcapt][ oby])
  // otherwise you can get rounding problems when N is large.
  // You have been warned !

  if (tot_lglk != tot_lglk) {  //for debugging to see what's going on w/ tot_lglk=NA 
	  isex = 2;
  }
return( tot_lglk);
}; // lglk


// ----------------------------------------------------------------------------

// sqrt of all CKMR probs--- needed iff DESIGNcopy
void Bearded2::sqrt_probs(
  const ARRAY_1D pars/* n_par */
){
  int pby, pcapt, oby,isex,oby2;
  ////

  unpack(pars);
  populate( 0); // dummy arg; ADT bug
  calc_probs( 0);
  zero(sqrt_Pr_PO_ytbs);
  zero(sqrt_Pr_HS_bbs);
  for( pby = first_y; pby <= last_y; pby++){
    for( pcapt = first_y ; pcapt <= last_y; pcapt++){
      for( oby = first_y ; oby <= last_y; oby++){
		  for (isex = 0; isex <= 1; isex++) {
			  sqrt_Pr_PO_ytbs[pby][pcapt][oby][isex] = sqrt(Pr_PO_ytbs[pby][pcapt][oby][isex]);
		  }
      }
    }
  }
  for (isex = 0; isex <= 1; isex++) {
	  for (oby = first_y; oby < last_y; oby++) {
		  for (oby2 = oby + 1; oby2 <= last_y; oby2++) {
			  sqrt_Pr_HS_bbs[oby][oby2][isex] = sqrt(Pr_HS_bbs[oby][oby2][isex]);
		  }
	  }
  } 
} // sqrt_probs

// ----------------------------------------------------------------------------
// Destructor: leave this alone
Bearded2::~Bearded2(){}; // destructor

// ----------------------------------------------------------------------------
// Support routine; this and dr_n_log_p should be part of ADT maths lib, with black-box too
double n_log_p(
  const int n,
  const double p)
{
  return( n * log( p + one_if( p==0)));
}; // n_log_p


