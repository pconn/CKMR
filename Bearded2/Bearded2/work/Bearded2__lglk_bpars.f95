!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.13 (r6666M) - 28 May 2018 09:20
!
! ----------------------------------------------------------------------------
MODULE COMMON_B
  IMPLICIT NONE
  INTEGER, PARAMETER :: dim_stack
  INTEGER :: a(n_samp)
  INTEGER :: amat
  INTEGER :: by(n_samp)
  INTEGER :: first_y
  INTEGER :: first_y_sample
  REAL :: inv_totfec_ys(first_y:last_y, 0:1)
  REAL :: inv_totfec_ysb1_pars(first_y:last_y, 0:1)
  INTEGER :: isamp_pop(n_pop)
  INTEGER :: jsamp_pop(n_pop)
  INTEGER :: last_y
  REAL*8 :: n0_f
  REAL*8 :: n0_fb1_pars
  REAL*8 :: n0_m
  REAL*8 :: n0_mb1_pars
  INTEGER :: n_comps_ytbsm(first_y:last_y, first_y:last_y, first_y:&
& last_y, 0:1, 0:1)
  INTEGER :: n_par
  INTEGER :: n_pop
  INTEGER :: n_samp
  REAL :: n_ys(first_y:last_y, 0:1)
  REAL :: n_ysb1_pars(first_y:last_y, 0:1)
  INTEGER :: nextpari
  REAL :: pr_po_ytbs(first_y:last_y, first_y:last_y, first_y:last_y, 0:1&
& )
  REAL :: pr_po_ytbsb1_pars(first_y:last_y, first_y:last_y, first_y:&
& last_y, 0:1)
  REAL*8 :: roi
  REAL*8 :: roib1_pars
  INTEGER :: sex(n_samp)
  REAL :: sqrt_pr_po_ytbs(first_y:last_y, first_y:last_y, first_y:last_y&
& , 0:1)
  INTEGER :: tcap(n_samp)
  REAL :: temp_pars(n_par)
  REAL :: temp_parsb1_pars(n_par)
  INTEGER :: ymat_atmost(n_samp)
END MODULE COMMON_B

!  Differentiation of bearded2__lglk in reverse (adjoint) mode:
!   gradient     of useful results: bearded2__lglk
!   with respect to varying inputs: pars
!   RW status of diff variables: roi:(loc) inv_totfec_ys:(loc)
!                n_ys:(loc) temp_pars:(loc) n0_f:(loc) pr_po_ytbs:(loc)
!                n0_m:(loc) bearded2__lglk:in-killed pars:out
! isex
!  oby
!  pcapt
!  pmaty
!  calc_probs
!  ----------------------------------------------------------------------------
!  Log-likelihood
SUBROUTINE BEARDED2__LGLK_BPARS(pars, parsb1_pars, bearded2__lglkb1_pars&
&)
  IMPLICIT NONE
  REAL, INTENT(IN) :: pars(n_par)
  REAL :: parsb1_pars(n_par)
  USE COMMON_B
  INTEGER :: pby, pcapt, oby, isex
  REAL*8 :: tot_lglk
  REAL*8 :: tot_lglkb1_pars
  REAL*8 :: N_LOG_P
  REAL :: arg1
  REAL :: arg1b1_pars
  REAL*8 :: result1
  REAL*8 :: result1b1_pars
  INTEGER :: ad_count
  INTEGER :: i
  INTEGER :: ad_count0
  INTEGER :: i0
  INTEGER :: ad_count1
  INTEGER :: i1
  INTEGER :: ad_count2
  INTEGER :: i2
  INTEGER :: ad_count3
  INTEGER :: i3
  INTEGER :: ad_count4
  INTEGER :: i4
  INTEGER :: ad_count5
  INTEGER :: i5
  INTEGER :: ad_count6
  INTEGER :: i6
  REAL*8 :: bearded2__lglk
  REAL*8 :: bearded2__lglkb1_pars
! //
  CALL PUSHREAL4ARRAY(temp_pars, n_par)
  CALL BEARDED2__UNPACK_CB(pars)
!  dummy arg
  CALL PUSHREAL4ARRAY(n_ys, (last_y-first_y+1)*2)
  CALL BEARDED2__POPULATE(0)
  CALL BEARDED2__CALC_PROBS(0)
  pby = first_y
  ad_count2 = 0
  DO WHILE (pby .LE. last_y)
    pcapt = first_y
    ad_count1 = 0
    DO WHILE (pcapt .LE. last_y)
      oby = first_y
      ad_count0 = 0
      DO WHILE (oby .LE. last_y)
        isex = 0
        ad_count = 0
        DO WHILE (isex .LE. 1)
!  Poisson approximation: fine if N is fairly big
! 
!         				  tot_lglk +=
!         					-n_comps_ytb[pmaty][pcapt][oby] *
!         					Pr_PO_ytb[pmaty][pcapt][oby]
!         					+ n_log_p(
!         						n_PO_ytb[pmaty][pcapt][oby],
!         						n_comps_ytb[pmaty][pcapt][oby] *
!         						Pr_PO_ytb[pmaty][pcapt][oby]
!         					);
!         				  
          CALL PUSHINTEGER4(isex)
          isex = isex + 1
          ad_count = ad_count + 1
        END DO
        CALL PUSHINTEGER4(ad_count)
        CALL PUSHINTEGER4(oby)
        oby = oby + 1
        ad_count0 = ad_count0 + 1
      END DO
      CALL PUSHINTEGER4(ad_count0)
      CALL PUSHINTEGER4(pcapt)
      pcapt = pcapt + 1
      ad_count1 = ad_count1 + 1
    END DO
    CALL PUSHINTEGER4(ad_count1)
    CALL PUSHINTEGER4(pby)
    pby = pby + 1
    ad_count2 = ad_count2 + 1
  END DO
  CALL PUSHINTEGER4(ad_count2)
! isex
!  oby
!  pcapt
!  pmaty
  pby = first_y
  ad_count6 = 0
  DO WHILE (pby .LE. last_y)
    pcapt = first_y
    ad_count5 = 0
    DO WHILE (pcapt .LE. last_y)
      oby = first_y
      ad_count4 = 0
      DO WHILE (oby .LE. last_y)
        isex = 0
        ad_count3 = 0
        DO WHILE (isex .LE. 1)
          CALL PUSHINTEGER4(isex)
          isex = isex + 1
          ad_count3 = ad_count3 + 1
        END DO
        CALL PUSHINTEGER4(ad_count3)
        CALL PUSHINTEGER4(oby)
        oby = oby + 1
        ad_count4 = ad_count4 + 1
      END DO
      CALL PUSHINTEGER4(ad_count4)
      CALL PUSHINTEGER4(pcapt)
      pcapt = pcapt + 1
      ad_count5 = ad_count5 + 1
    END DO
    CALL PUSHINTEGER4(ad_count5)
    CALL PUSHINTEGER4(pby)
    pby = pby + 1
    ad_count6 = ad_count6 + 1
  END DO
  CALL PUSHINTEGER4(ad_count6)
  tot_lglkb1_pars = bearded2__lglkb1_pars
  pr_po_ytbsb1_pars = 0.0
  CALL POPINTEGER4(ad_count6)
  DO i6=1,ad_count6
    CALL POPINTEGER4(pby)
    CALL POPINTEGER4(ad_count5)
    DO i5=1,ad_count5
      CALL POPINTEGER4(pcapt)
      CALL POPINTEGER4(ad_count4)
      DO i4=1,ad_count4
        CALL POPINTEGER4(oby)
        CALL POPINTEGER4(ad_count3)
        DO i3=1,ad_count3
          CALL POPINTEGER4(isex)
          result1b1_pars = tot_lglkb1_pars
          CALL N_LOG_P_BPARS(n_comps_ytbsm(pby, pcapt, oby, isex, 1), &
&                      pr_po_ytbs(pby, pcapt, oby, isex), &
&                      pr_po_ytbsb1_pars(pby, pcapt, oby, isex), &
&                      result1b1_pars)
        END DO
      END DO
    END DO
  END DO
  CALL POPINTEGER4(ad_count2)
  DO i2=1,ad_count2
    CALL POPINTEGER4(pby)
    CALL POPINTEGER4(ad_count1)
    DO i1=1,ad_count1
      CALL POPINTEGER4(pcapt)
      CALL POPINTEGER4(ad_count0)
      DO i0=1,ad_count0
        CALL POPINTEGER4(oby)
        CALL POPINTEGER4(ad_count)
        DO i=1,ad_count
          CALL POPINTEGER4(isex)
          result1b1_pars = tot_lglkb1_pars
          arg1 = 1 - pr_po_ytbs(pby, pcapt, oby, isex)
          arg1b1_pars = 0.0
          CALL N_LOG_P_BPARS(n_comps_ytbsm(pby, pcapt, oby, isex, 0), &
&                      arg1, arg1b1_pars, result1b1_pars)
          pr_po_ytbsb1_pars(pby, pcapt, oby, isex) = pr_po_ytbsb1_pars(&
&           pby, pcapt, oby, isex) - arg1b1_pars
        END DO
      END DO
    END DO
  END DO
  CALL BEARDED2__CALC_PROBS_BPARS(0)
  CALL POPREAL4ARRAY(n_ys, (last_y-first_y+1)*2)
  CALL BEARDED2__POPULATE_BPARS(0)
  CALL POPREAL4ARRAY(temp_pars, n_par)
  CALL BEARDED2__UNPACK_BPARS(pars, parsb1_pars)
END SUBROUTINE BEARDED2__LGLK_BPARS

!  Differentiation of bearded2__calc_probs in reverse (adjoint) mode:
!   gradient     of useful results: pr_po_ytbs
!   with respect to varying inputs: inv_totfec_ys
! ----------------------------------------------------------------------------
! isex
! y
!  populate
!  ---------------------------------------------------------------------------
!  All CKMR probs
SUBROUTINE BEARDED2__CALC_PROBS_BPARS(dummy)
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: dummy
  USE COMMON_B
  INTEGER :: pby, pdy, pcapt, pmaty, isex, oby
  INTEGER :: ONE_IF
  INTEGER :: result1
  INTEGER :: result2
  INTEGER :: result3
  INTEGER :: result4
  INTEGER :: ad_count
  INTEGER :: i
  INTEGER :: ad_count0
  INTEGER :: i0
  INTEGER :: ad_count1
  INTEGER :: i1
  INTEGER :: ad_count2
  INTEGER :: i2
  pby = first_y
  ad_count2 = 0
  DO WHILE (pby .LE. last_y)
    pcapt = first_y_sample
    ad_count1 = 0
    DO WHILE (pcapt .LE. last_y)
      oby = first_y
      ad_count0 = 0
      DO WHILE (oby .LE. last_y)
        isex = 0
        ad_count = 0
        DO WHILE (isex .LE. 1)
          pmaty = pby + amat
          CALL PUSHINTEGER4(result1)
          result1 = ONE_IF(pmaty .LE. oby)
          CALL PUSHINTEGER4(result2)
          result2 = ONE_IF(pcapt .GT. oby)
          CALL PUSHINTEGER4(result3)
          result3 = ONE_IF(pcapt - pby .LE. 38)
          CALL PUSHINTEGER4(result4)
          result4 = ONE_IF(pby - oby .LE. 38)
          CALL PUSHINTEGER4(isex)
          isex = isex + 1
          ad_count = ad_count + 1
        END DO
        CALL PUSHINTEGER4(ad_count)
        CALL PUSHINTEGER4(oby)
        oby = oby + 1
        ad_count0 = ad_count0 + 1
      END DO
      CALL PUSHINTEGER4(ad_count0)
      CALL PUSHINTEGER4(pcapt)
      pcapt = pcapt + 1
      ad_count1 = ad_count1 + 1
    END DO
    CALL PUSHINTEGER4(ad_count1)
    CALL PUSHINTEGER4(pby)
    pby = pby + 1
    ad_count2 = ad_count2 + 1
  END DO
  inv_totfec_ysb1_pars = 0.0
  DO i2=1,ad_count2
    CALL POPINTEGER4(pby)
    CALL POPINTEGER4(ad_count1)
    DO i1=1,ad_count1
      CALL POPINTEGER4(pcapt)
      CALL POPINTEGER4(ad_count0)
      DO i0=1,ad_count0
        CALL POPINTEGER4(oby)
        CALL POPINTEGER4(ad_count)
        DO i=1,ad_count
          CALL POPINTEGER4(isex)
          inv_totfec_ysb1_pars(oby, isex) = inv_totfec_ysb1_pars(oby, &
&           isex) + result3*result4*result1*result2*pr_po_ytbsb1_pars(&
&           pby, pcapt, oby, isex)
          pr_po_ytbsb1_pars(pby, pcapt, oby, isex) = 0.0
          CALL POPINTEGER4(result4)
          CALL POPINTEGER4(result3)
          CALL POPINTEGER4(result2)
          pmaty = pby + amat
          CALL POPINTEGER4(result1)
        END DO
      END DO
    END DO
  END DO
END SUBROUTINE BEARDED2__CALC_PROBS_BPARS

! isex
!  oby
!  pcapt
!  pmaty
!  calc_probs
!  ----------------------------------------------------------------------------
!  Log-likelihood
FUNCTION BEARDED2__LGLK_CB(pars) RESULT (BEARDED2__LGLK)
  IMPLICIT NONE
  REAL, INTENT(IN) :: pars(n_par)
  USE COMMON_B
  INTEGER :: pby, pcapt, oby, isex
  REAL*8 :: tot_lglk
  REAL*8 :: N_LOG_P
  REAL :: arg1
  REAL*8 :: result1
  REAL*8 :: bearded2__lglk
! //
  CALL BEARDED2__UNPACK_CB(pars)
!  dummy arg
  CALL BEARDED2__POPULATE(0)
  CALL BEARDED2__CALC_PROBS(0)
  tot_lglk = 0
  pby = first_y
  DO WHILE (pby .LE. last_y)
    pcapt = first_y
    DO WHILE (pcapt .LE. last_y)
      oby = first_y
      DO WHILE (oby .LE. last_y)
        isex = 0
        DO WHILE (isex .LE. 1)
!  Poisson approximation: fine if N is fairly big
! 
!         				  tot_lglk +=
!         					-n_comps_ytb[pmaty][pcapt][oby] *
!         					Pr_PO_ytb[pmaty][pcapt][oby]
!         					+ n_log_p(
!         						n_PO_ytb[pmaty][pcapt][oby],
!         						n_comps_ytb[pmaty][pcapt][oby] *
!         						Pr_PO_ytb[pmaty][pcapt][oby]
!         					);
!         				  
          arg1 = 1 - pr_po_ytbs(pby, pcapt, oby, isex)
          result1 = N_LOG_P(n_comps_ytbsm(pby, pcapt, oby, isex, 0), &
&           arg1)
          tot_lglk = tot_lglk + result1
          isex = isex + 1
        END DO
        oby = oby + 1
      END DO
      pcapt = pcapt + 1
    END DO
    pby = pby + 1
  END DO
! isex
!  oby
!  pcapt
!  pmaty
  pby = first_y
  DO WHILE (pby .LE. last_y)
    pcapt = first_y
    DO WHILE (pcapt .LE. last_y)
      oby = first_y
      DO WHILE (oby .LE. last_y)
        isex = 0
        DO WHILE (isex .LE. 1)
          result1 = N_LOG_P(n_comps_ytbsm(pby, pcapt, oby, isex, 1), &
&           pr_po_ytbs(pby, pcapt, oby, isex))
          tot_lglk = tot_lglk + result1
          isex = isex + 1
        END DO
        oby = oby + 1
      END DO
      pcapt = pcapt + 1
    END DO
    pby = pby + 1
  END DO
!  isex
!  oby
!  pcapt
!  pmaty
!  Binomial version could be:
!  tot_lglk += n_log_p( n_PO_ytb[ pmaty][ pcapt][ oby],
!       Pr_PO_ytb[ pmaty][ pcapt][ oby]) +
!     n_log_p( n_comps_ytb[ pmaty][ pcapt][ oby] - n_PO_ytb[ pmaty][ pcapt][ oby],
!       1-Pr_PO_ytb[ pmaty][ pcapt][ oby]);
!  Bin version *without* n_log_p needs if-statements to avoid log(0)
!  and should use log1p( -Pr_PO_ytb[ pmaty][ pcapt][ oby])
!  otherwise you can get rounding problems when N is large.
!  You have been warned !
  IF (tot_lglk .NE. tot_lglk) isex = 2
  bearded2__lglk = tot_lglk
  RETURN
END FUNCTION BEARDED2__LGLK_CB

!  include-files below are auto-generated by ADT based on the dot-hpp
!  Next line may bomb if no constructor-locals (used to; maybe fixed now)
!  Always need these two
!  Now you can do some calculations to work out further array dims...
!  that depend on stuff just passed in. Then:
!  eg  #include "Bd_constructor_arrays_phase_2.hpp"
!  etc. Might as well pass in all scalars during PHASE 1 though
!  NB PHASES are defined in the dot-hpp
!  Could do data-summary calcs here
!  but NB *no* bounds-checks inside the constructor (for good reason)
!  so I've put them into a separate function
!  Hmmm, should check: ?arrays that need to be precalced...
!  before array_plans_init
!  make_data_summaries(); Has to be called OUTSIDE the constructor at present... ADT / ViStu thing
!  constructor
SUBROUTINE BEARDED2__MAKE_DATA_SUMMARIES_CB()
  USE COMMON_B
  IMPLICIT NONE
  INTEGER :: i_samp, j_samp, this_by, this_oby, this_capt, this_pby, &
& this_maty, this_sex, i_pop
  INTRINSIC MAX
!  compute birth years for each sampled animal
  i_samp = 1
  DO WHILE (i_samp .LE. n_samp)
    this_by = tcap(i_samp) - a(i_samp)
    by(i_samp) = this_by
    IF (first_y .LT. this_by + amat) THEN
      ymat_atmost(i_samp) = this_by + amat
    ELSE
      ymat_atmost(i_samp) = first_y
    END IF
    i_samp = i_samp + 1
  END DO
!  i_samp
  n_comps_ytbsm = 0
  i_samp = 1
  DO WHILE (i_samp .LT. n_samp)
    j_samp = i_samp + 1
    DO WHILE (j_samp .LE. n_samp)
!  In this case, exclude comps where adult caught in year of juve birth...
!  depends on biol & sampling
!  First case: i is P, j is O
      this_oby = by(j_samp)
      this_pby = by(i_samp)
      this_capt = tcap(i_samp)
      this_maty = ymat_atmost(i_samp)
      this_sex = sex(i_samp)
!  exclude born-in-year-of-cap - this will also remove case where offspring born <= year 1
      IF (this_oby .GE. this_maty .AND. this_maty .LE. last_y .AND. &
&         this_oby .LT. this_capt .AND. this_oby .NE. this_capt) &
&       n_comps_ytbsm(this_pby, this_capt, this_oby, this_sex, 0) = &
&         n_comps_ytbsm(this_pby, this_capt, this_oby, this_sex, 0) + 1
!  Second case: i is O, j is P
      this_oby = by(i_samp)
      this_pby = by(j_samp)
      this_capt = tcap(j_samp)
      this_maty = ymat_atmost(j_samp)
      this_sex = sex(j_samp)
!  exclude born-in-year-of-cap - this will also remove case where offspring born <= year 1
      IF (this_oby .GE. this_maty .AND. this_maty .LE. last_y .AND. &
&         this_oby .LT. this_capt .AND. this_oby .NE. this_capt) &
&       n_comps_ytbsm(this_pby, this_capt, this_oby, this_sex, 0) = &
&         n_comps_ytbsm(this_pby, this_capt, this_oby, this_sex, 0) + 1
      j_samp = j_samp + 1
    END DO
    i_samp = i_samp + 1
  END DO
!  jsamp
!  isamp
  i_pop = 1
  DO WHILE (i_pop .LT. n_pop)
    i_samp = isamp_pop(i_pop)
    j_samp = jsamp_pop(i_pop)
!  First case: i is P, j is O
    this_oby = by(j_samp)
    this_pby = by(i_samp)
    this_capt = tcap(i_samp)
    this_maty = ymat_atmost(i_samp)
    this_sex = sex(i_samp)
!  exclude born-in-year-of-cap - this will also remove case where offspring born <= year 1
    IF (this_oby .GE. this_maty .AND. this_maty .LE. last_y .AND. &
&       this_oby .LT. this_capt .AND. this_oby .NE. this_capt) THEN
! have to take away from negative comparisons 
      n_comps_ytbsm(this_pby, this_capt, this_oby, this_sex, 0) = &
&       n_comps_ytbsm(this_pby, this_capt, this_oby, this_sex, 0) - 1
      n_comps_ytbsm(this_pby, this_capt, this_oby, this_sex, 1) = &
&       n_comps_ytbsm(this_pby, this_capt, this_oby, this_sex, 1) + 1
    END IF
!  Second case: i is O, j is P
    this_oby = by(i_samp)
    this_pby = by(j_samp)
    this_capt = tcap(j_samp)
    this_maty = ymat_atmost(j_samp)
    this_sex = sex(j_samp)
!  exclude born-in-year-of-cap - this will also remove case where offspring born <= year 1
    IF (this_oby .GE. this_maty .AND. this_maty .LE. last_y .AND. &
&       this_oby .LT. this_capt .AND. this_oby .NE. this_capt) THEN
! have to take away from negative comparisons 
      n_comps_ytbsm(this_pby, this_capt, this_oby, this_sex, 0) = &
&       n_comps_ytbsm(this_pby, this_capt, this_oby, this_sex, 0) - 1
      n_comps_ytbsm(this_pby, this_capt, this_oby, this_sex, 1) = &
&       n_comps_ytbsm(this_pby, this_capt, this_oby, this_sex, 1) + 1
    END IF
    i_pop = i_pop + 1
  END DO
END SUBROUTINE BEARDED2__MAKE_DATA_SUMMARIES_CB

!  Hide the next bit from  ADT; for one thing, strings aren't understood...
!  but there never any reason to AD this, so don't
!  unpack
!  Helper for unpack
FUNCTION BEARDED2__NEXT_PARAM_CB() RESULT (BEARDED2__NEXT_PARAM)
  USE COMMON_B
  IMPLICIT NONE
  REAL*8 :: val
  REAL*8 :: bearded2__next_param
! //
  val = temp_pars(nextpari)
  nextpari = nextpari + 1
  bearded2__next_param = val
  RETURN
END FUNCTION BEARDED2__NEXT_PARAM_CB

!  Differentiation of bearded2__populate in reverse (adjoint) mode:
!   gradient     of useful results: inv_totfec_ys
!   with respect to varying inputs: roi n0_f n0_m
!  next_param
!  ---------------------------------------------------------------------------
!  Fill in pop dyn from parameters. Age-structured version is more interesting
SUBROUTINE BEARDED2__POPULATE_BPARS(dummy)
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: dummy
  USE COMMON_B
  INTEGER :: y, isex
  INTEGER :: ad_count
  INTEGER :: i
  INTEGER :: ad_count0
  INTEGER :: i0
  INTEGER :: ad_count1
  INTEGER :: i1
  INTEGER :: ad_count2
  INTEGER :: i2
  n_ys(first_y, 0) = n0_f
  n_ys(first_y, 1) = n0_m
  y = first_y + 1
  ad_count0 = 0
  DO WHILE (y .LE. last_y)
    isex = 0
    ad_count = 0
    DO WHILE (isex .LE. 1)
      CALL PUSHREAL4(n_ys(y, isex))
      n_ys(y, isex) = n_ys(y-1, isex)*roi
      CALL PUSHINTEGER4(isex)
      isex = isex + 1
      ad_count = ad_count + 1
    END DO
    CALL PUSHINTEGER4(ad_count)
    CALL PUSHINTEGER4(y)
    y = y + 1
    ad_count0 = ad_count0 + 1
  END DO
  CALL PUSHINTEGER4(ad_count0)
! isex
! y
!  Might as well do Total Reprod Output here in populate(), though...
!  could also do in calc_probs. Actually we just need the inverse
  y = first_y
  ad_count2 = 0
  DO WHILE (y .LE. last_y)
    isex = 0
    ad_count1 = 0
    DO WHILE (isex .LE. 1)
      CALL PUSHINTEGER4(isex)
      isex = isex + 1
      ad_count1 = ad_count1 + 1
    END DO
    CALL PUSHINTEGER4(ad_count1)
    CALL PUSHINTEGER4(y)
    y = y + 1
    ad_count2 = ad_count2 + 1
  END DO
  n_ysb1_pars = 0.0
  DO i2=1,ad_count2
    CALL POPINTEGER4(y)
    CALL POPINTEGER4(ad_count1)
    DO i1=1,ad_count1
      CALL POPINTEGER4(isex)
      n_ysb1_pars(y, isex) = n_ysb1_pars(y, isex) - inv_totfec_ysb1_pars&
&       (y, isex)/n_ys(y, isex)**2
      inv_totfec_ysb1_pars(y, isex) = 0.0
    END DO
  END DO
  roib1_pars = 0.0_8
  CALL POPINTEGER4(ad_count0)
  DO i0=1,ad_count0
    CALL POPINTEGER4(y)
    CALL POPINTEGER4(ad_count)
    DO i=1,ad_count
      CALL POPINTEGER4(isex)
      CALL POPREAL4(n_ys(y, isex))
      n_ysb1_pars(y-1, isex) = n_ysb1_pars(y-1, isex) + roi*n_ysb1_pars(&
&       y, isex)
      roib1_pars = roib1_pars + n_ys(y-1, isex)*n_ysb1_pars(y, isex)
      n_ysb1_pars(y, isex) = 0.0
    END DO
  END DO
  n0_mb1_pars = n_ysb1_pars(first_y, 1)
  n_ysb1_pars(first_y, 1) = 0.0
  n0_fb1_pars = n_ysb1_pars(first_y, 0)
END SUBROUTINE BEARDED2__POPULATE_BPARS

!  lglk
!  ----------------------------------------------------------------------------
!  sqrt of all CKMR probs--- needed iff DESIGNcopy
SUBROUTINE BEARDED2__SQRT_PROBS_CB(pars)
  IMPLICIT NONE
  REAL, INTENT(IN) :: pars(n_par)
  USE COMMON_B
  INTEGER :: pby, pcapt, oby, isex
  INTRINSIC SQRT
! //
  CALL BEARDED2__UNPACK_CB(pars)
!  dummy arg; ADT bug
  CALL BEARDED2__POPULATE(0)
  CALL BEARDED2__CALC_PROBS(0)
  sqrt_pr_po_ytbs = 0
  pby = first_y
  DO WHILE (pby .LE. last_y)
    pcapt = first_y
    DO WHILE (pcapt .LE. last_y)
      oby = first_y
      DO WHILE (oby .LE. last_y)
        isex = 0
        DO WHILE (isex .LE. 1)
          sqrt_pr_po_ytbs(pby, pcapt, oby, isex) = SQRT(pr_po_ytbs(pby, &
&           pcapt, oby, isex))
          isex = isex + 1
        END DO
        oby = oby + 1
      END DO
      pcapt = pcapt + 1
    END DO
    pby = pby + 1
  END DO
END SUBROUTINE BEARDED2__SQRT_PROBS_CB

!  Differentiation of bearded2__unpack in reverse (adjoint) mode:
!   gradient     of useful results: roi n0_f n0_m
!   with respect to varying inputs: pars
!  i_POP
!  ... NB I don't mind using if's in the constructor, since it's only run once
!  ... in lglk code, one_if() is faster
!  make_data_summaries
!  ----------------------------------------------------------------------------
!  Unpack R parameter-vector into meaningful pop dyn params
SUBROUTINE BEARDED2__UNPACK_BPARS(pars, parsb1_pars)
  IMPLICIT NONE
  REAL, INTENT(IN) :: pars(n_par)
  REAL :: parsb1_pars(n_par)
  USE COMMON_B
  INTEGER :: i
  REAL*8 :: BEARDED2__NEXT_PARAM_CB
  INTRINSIC EXP
  REAL*8 :: result1
  REAL*8 :: result1b1_pars
  INTEGER :: ad_count
  INTEGER :: i0
!  Surely there is a copy-style function in ADT/C ? No doc of it tho
!  ADT Pascal has one
  i = 1
  ad_count = 0
  DO WHILE (i .LE. n_par)
    temp_pars(i) = pars(i)
    CALL PUSHINTEGER4(i)
    i = i + 1
    ad_count = ad_count + 1
  END DO
  CALL PUSHINTEGER4(ad_count)
  nextpari = 1
  CALL PUSHINTEGER4(nextpari)
  result1 = BEARDED2__NEXT_PARAM_CB()
  CALL PUSHINTEGER4(nextpari)
  CALL PUSHREAL8(result1)
  result1 = BEARDED2__NEXT_PARAM_CB()
  CALL PUSHINTEGER4(nextpari)
  CALL PUSHREAL8(result1)
  result1 = BEARDED2__NEXT_PARAM_CB()
  result1b1_pars = EXP(result1)*n0_mb1_pars
  CALL POPREAL8(result1)
  CALL POPINTEGER4(nextpari)
  temp_parsb1_pars = 0.0
  CALL BEARDED2__NEXT_PARAM_BPARS(result1b1_pars)
  result1b1_pars = EXP(result1)*n0_fb1_pars
  CALL POPREAL8(result1)
  CALL POPINTEGER4(nextpari)
  CALL BEARDED2__NEXT_PARAM_BPARS(result1b1_pars)
  result1b1_pars = EXP(result1)*roib1_pars
  CALL POPINTEGER4(nextpari)
  CALL BEARDED2__NEXT_PARAM_BPARS(result1b1_pars)
  parsb1_pars = 0.0
  CALL POPINTEGER4(ad_count)
  DO i0=1,ad_count
    CALL POPINTEGER4(i)
    parsb1_pars(i) = parsb1_pars(i) + temp_parsb1_pars(i)
    temp_parsb1_pars(i) = 0.0
  END DO
END SUBROUTINE BEARDED2__UNPACK_BPARS

!  Differentiation of bearded2__next_param in reverse (adjoint) mode:
!   gradient     of useful results: temp_pars bearded2__next_param
!   with respect to varying inputs: temp_pars
!  Hide the next bit from  ADT; for one thing, strings aren't understood...
!  but there never any reason to AD this, so don't
!  unpack
!  Helper for unpack
SUBROUTINE BEARDED2__NEXT_PARAM_BPARS(bearded2__next_paramb1_pars)
  USE COMMON_B
  IMPLICIT NONE
  REAL*8 :: val
  REAL*8 :: valb1_pars
! //
  REAL*8 :: bearded2__next_paramb1_pars
  REAL*8 :: bearded2__next_param
  valb1_pars = bearded2__next_paramb1_pars
  temp_parsb1_pars(nextpari) = temp_parsb1_pars(nextpari) + valb1_pars
END SUBROUTINE BEARDED2__NEXT_PARAM_BPARS

!  i_POP
!  ... NB I don't mind using if's in the constructor, since it's only run once
!  ... in lglk code, one_if() is faster
!  make_data_summaries
!  ----------------------------------------------------------------------------
!  Unpack R parameter-vector into meaningful pop dyn params
SUBROUTINE BEARDED2__UNPACK_CB(pars)
  IMPLICIT NONE
  REAL, INTENT(IN) :: pars(n_par)
  USE COMMON_B
  INTEGER :: i
  REAL*8 :: BEARDED2__NEXT_PARAM_CB
  INTRINSIC EXP
  REAL*8 :: result1
!  Surely there is a copy-style function in ADT/C ? No doc of it tho
!  ADT Pascal has one
  i = 1
  DO WHILE (i .LE. n_par)
    temp_pars(i) = pars(i)
    i = i + 1
  END DO
  nextpari = 1
  result1 = BEARDED2__NEXT_PARAM_CB()
  roi = EXP(result1)
  result1 = BEARDED2__NEXT_PARAM_CB()
  n0_f = EXP(result1)
  result1 = BEARDED2__NEXT_PARAM_CB()
  n0_m = EXP(result1)
END SUBROUTINE BEARDED2__UNPACK_CB

!  Differentiation of n_log_p in reverse (adjoint) mode:
!   gradient     of useful results: p n_log_p
!   with respect to varying inputs: p
!  ----------------------------------------------------------------------------
!  Support routine; this and dr_n_log_p should be part of ADT maths lib, with black-box too
SUBROUTINE N_LOG_P_BPARS(n, p, pb1_pars, n_log_pb1_pars)
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: n
  REAL*8, INTENT(IN) :: p
  REAL*8 :: pb1_pars
  USE COMMON_B
  INTEGER :: ONE_IF
  INTRINSIC LOG
  INTEGER :: result1
  REAL*8 :: n_log_pb1_pars
  REAL*8 :: n_log_p
  result1 = ONE_IF(p .EQ. 0)
  pb1_pars = pb1_pars + n*n_log_pb1_pars/(result1+p)
END SUBROUTINE N_LOG_P_BPARS

