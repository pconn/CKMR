// ----------------------------------------------------------------------------
// Bearded2.cpp
// ----------------------------------------------------------------------------
// BasiCKMR: single-sex boring-adulthood known-age POP-only (MDP) CKMR
// assumes long-term exponential growth/decline in Number-of-adults

#include "Bearded2.hpp"
#include <R.h>


// ----------------------------------------------------------------------------


// CONSTRUCTOR: you may not need to change this, if your data all comes from...
// R in one single hit
Bearded2::Bearded2(
#include "Bd_constructor_args.hpp"
)
 : AdtArrays()
{

  // include-files below are auto-generated by ADT based on the dot-hpp
  // Next line may bomb if no constructor-locals (used to; maybe fixed now)
  #include "Bd_constructor_locals.hpp"

  // Always need these two
  #include "Bd_constructor_scalars_phase_1.hpp"
  #include "Bd_constructor_arrays_phase_1.hpp"

  // Now you can do some calculations to work out further array dims...
  // that depend on stuff just passed in. Then:
  // eg  #include "Bd_constructor_arrays_phase_2.hpp"
  // etc. Might as well pass in all scalars during PHASE 1 though
  // NB PHASES are defined in the dot-hpp

  // Could do data-summary calcs here
  // but NB *no* bounds-checks inside the constructor (for good reason)
  // so I've put them into a separate function
  // Hmmm, should check: ?arrays that need to be precalced...
  // before array_plans_init

  // make_data_summaries(); Has to be called OUTSIDE the constructor at present... ADT / ViStu thing

  #include "Bd_array_plans_init.hpp"
}; // constructor

void Bearded2::make_data_summaries()
{
  int pby, pcapt, oby,
    i_samp, j_samp, this_by, this_capt, this_maty,
    i_POP;

   // compute birth years for each sampled animal
  for( i_samp = 1; i_samp <= n_samp; i_samp++) {
    this_by = tcap[ i_samp] - a[ i_samp];
    by[ i_samp] = this_by;

    // For i_samp as possible parent, need year of maturity...
    // or, if that's < first_y, just use first_y...
	ymat_atmost[ i_samp] = max( first_y, this_by + amat);  //note: we'll need to avoid doing comparisons where parent and offspring are both "born" in first_y
  }; // i_samp

  // Number of comparisons. Here we are treating PO as DIRECTIONAL, ie
  // 1st animal in the pair must be the Parent, and 2nd animal the Offspring
  // Look at calc_probs code first to understand why these variables are use
  
  // # comparisons by adult birth year [y], adult death year [t], young birth year [b], sex [s], and whether there is a match or not [m]
  zero(n_comps_ytbsm);

  for (i_samp = 1; isamp < n_samp;isamp++) {
    for( jsamp = isamp+1; jsamp<=n_samp; jsamp++){
		// In this case, exclude comps where adult caught in year of juve birth...
		// depends on biol & sampling
				n_comps_ytb[pmaty][pcapt][oby] = one_if(pcapt != oby) * one_if(pmaty <= oby) *
				n_pmatalive_yt[pmaty][pcapt] * n_obirth_y[oby]; 
		}
      } // oby
    } // pcapt
  } // pmaty

  // Summarize POPs
  // DON'T include where
  zero( n_PO_ytb);
  for( i_POP = 1; i_POP <= n_POP; i_POP++) {
    i_samp = isamp_POP[ i_POP];
    j_samp = jsamp_POP[ i_POP];

    // First case: i is P, j is O
    this_by = by[ j_samp];
    this_capt = tcap[ i_samp];
    this_maty = ymat_atmost[ i_samp];

    // remember to exclude born-in-yaer-of-cap
    if(( this_by >= first_y) && (this_by >= this_maty) && (this_maty <= last_y)) {
      n_PO_ytb[ this_maty][ this_capt][ this_by] += 1;
    };

    // Second case: i is O, j is P
    this_by = by[ i_samp];
    this_capt = tcap[ j_samp];
    this_maty = ymat_atmost[ j_samp];

    // remember to exclude born-in-yaer-of-cap
    if(( this_by >= first_y) && (this_by >= this_maty) && (this_maty <= last_y)) {
      n_PO_ytb[ this_maty][ this_capt][ this_by] += 1;
    };
  }; // i_POP


  // ... NB I don't mind using if's in the constructor, since it's only run once
  // ... in lglk code, one_if() is faster

}; // make_data_summaries

// ----------------------------------------------------------------------------

// Unpack R parameter-vector into meaningful pop dyn params
void Bearded2::unpack(
  const ARRAY_1D pars/*n_par*/
){
  int i;

  // Surely there is a copy-style function in ADT/C ? No doc of it tho
  // ADT Pascal has one
  for ( i = 1; i <= n_par; i++) {
    temp_pars[ i] = pars[ i];
  }
  nextpari = 1;

  // Just two params in this model... so let's hope n_par==2
  roi = exp( next_param());
  N0 = exp( next_param());

  // Hide the next bit from  ADT; for one thing, strings aren't understood...
  // but there never any reason to AD this, so don't
  #ifndef AD
  if( nextpari != n_par+1) {
    Rf_error( "Wrong number of parameters was extracted in unpack...");
    // ... and that's how you signal an error
  };
  #endif
}; // unpack

// Helper for unpack
double Bearded2::next_param() {
  double val;
  ////
  val = temp_pars[ nextpari];
  nextpari += 1;
  return(val);
}; // next_param

// ---------------------------------------------------------------------------

// Fill in pop dyn from parameters. Age-structured version is more interesting
void Bearded2::populate(
  int dummy
){
  int y;

  n_y[ first_y] = N0;
  for( y = first_y+1; y <= last_y; y++){
    n_y[ y] = n_y[ y-1] * roi;
  };

  // Might as well do Total Reprod Output here in populate(), though...
  // could also do in calc_probs. Actually we just need the inverse
  for( y = first_y; y <= last_y; y++){
    inv_totfec_y[ y] = 1 / n_y[ y];
  };
}; // populate

// ---------------------------------------------------------------------------

// All CKMR probs
void Bearded2::calc_probs(
  int dummy
){
  int pmaty, pcapt, oby;
  ////

  zero( Pr_PO_ytb);

  for( pmaty = first_y; pmaty <= last_y; pmaty++){
    for( pcapt = first_y; pcapt <= last_y; pcapt++){
      for( oby = first_y; oby <= last_y; oby++){
        Pr_PO_ytb[ pmaty][ pcapt][ oby] =
            one_if( pmaty <= oby) * one_if( pcapt > oby) * inv_totfec_y[ oby];
      }; // oby
    }; // pcapt
  }; // pmaty
}; // calc_probs

// ----------------------------------------------------------------------------

// Log-likelihood
double Bearded2::lglk(
  const ARRAY_1D pars/* n_par */
){
  int pmaty, pcapt, oby;
  double tot_lglk;
  ////

  unpack(pars);
  populate(0); // dummy arg
  calc_probs(0);

  tot_lglk = 0;


  for (pmaty = first_y; pmaty <= last_y; pmaty++) {
	  for (pcapt = first_y; pcapt <= last_y; pcapt++) {
		  for (oby = first_y; oby <= last_y; oby++) {
			  // Poisson approximation: fine if N is fairly big
			  /*
			  tot_lglk +=
				  -n_comps_ytb[pmaty][pcapt][oby] *
				  Pr_PO_ytb[pmaty][pcapt][oby]
				  + n_log_p(
					  n_PO_ytb[pmaty][pcapt][oby],
					  n_comps_ytb[pmaty][pcapt][oby] *
					  Pr_PO_ytb[pmaty][pcapt][oby]
				  );
              */
			  
			  tot_lglk += n_log_p( n_PO_ytb[ pmaty][ pcapt][ oby],
			        Pr_PO_ytb[ pmaty][ pcapt][ oby]) +
			      n_log_p( n_comps_ytb[ pmaty][ pcapt][ oby] - n_PO_ytb[ pmaty][ pcapt][ oby],
			        1-Pr_PO_ytb[ pmaty][ pcapt][ oby]);
			  
		  }; // oby
	  }; // pcapt
  }; // pmaty

  // Binomial version could be:
  // tot_lglk += n_log_p( n_PO_ytb[ pmaty][ pcapt][ oby],
  //      Pr_PO_ytb[ pmaty][ pcapt][ oby]) +
  //    n_log_p( n_comps_ytb[ pmaty][ pcapt][ oby] - n_PO_ytb[ pmaty][ pcapt][ oby],
  //      1-Pr_PO_ytb[ pmaty][ pcapt][ oby]);

  // Bin version *without* n_log_p needs if-statements to avoid log(0)
  // and should use log1p( -Pr_PO_ytb[ pmaty][ pcapt][ oby])
  // otherwise you can get rounding problems when N is large.
  // You have been warned !


return( tot_lglk);
}; // lglk


// ----------------------------------------------------------------------------

// sqrt of all CKMR probs--- needed iff DESIGNcopy
void Bearded2::sqrt_probs(
  const ARRAY_1D pars/* n_par */
){
  int pmaty, pcapt, oby;
  ////

  unpack(pars);
  populate( 0); // dummy arg; ADT bug
  calc_probs( 0);

  for( pmaty = first_y; pmaty <= last_y; pmaty++){
    for( pcapt = first_y; pcapt <= last_y; pcapt++){
      for( oby = first_y; oby <= last_y; oby++){
        sqrt_Pr_PO_ytb[ pmaty][ pcapt][ oby] = sqrt( Pr_PO_ytb[ pmaty][ pcapt][ oby]);
      };
    };
  };
}; // sqrt_probs

// ----------------------------------------------------------------------------
// Destructor: leave this alone
Bearded2::~Bearded2(){}; // destructor

// ----------------------------------------------------------------------------
// Support routine; this and dr_n_log_p should be part of ADT maths lib, with black-box too
double n_log_p(
  const int n,
  const double p)
{
  return( n * log( p + one_if( p==0)));
}; // n_log_p


